# Early Paging Fundamentals: Single-Level Virtual Memory

This document explains the core concepts of **single-level paging** as used in early virtual memory systems (e.g., Atlas, IBM System/360 Model 67). Unlike modern multi-level schemes, early paging used a flat page table per processâ€”simple, efficient, and foundational to all modern memory management.

> ðŸ’¡ **Key Idea**: Virtual memory gives each process the illusion of a large, contiguous address spaceâ€”even though its data may be scattered across physical RAM.

---

## Core Components

| Component | Role |
|---------|------|
| **Virtual Address** | Generated by the program (e.g., `0x12345`). Split into **page number** + **offset**. |
| **Page Table** | An array where each entry maps a virtual page â†’ physical frame. Created per process. |
| **PTBR** (Page Table Base Register) | Hardware register holding the **physical address** of the current processâ€™s page table. |
| **MMU** (Memory Management Unit) | Hardware that translates virtual â†’ physical addresses using PTBR + page table. |
| **Page Fault** | CPU exception triggered when accessing an unmapped (invalid) virtual page. |

> ðŸ“Œ **Note**: The **offset is part of the virtual address itself**â€”it is **not stored in PTBR**.

---

## Address Translation (32-bit, 4KB Pages)

- Page size = 4KB â†’ **12-bit offset**
- Virtual address = 32 bits â†’ **20-bit page number** + **12-bit offset**
Virtual Address: [ 20-bit Page Number | 12-bit Offset ] â””â”€â”€â”€ index into â”€â”€â”€â”€â”˜ â””â”€ byte in page â”€â”˜


**Translation Steps**:
1. MMU reads **PTBR** to locate the page table in physical RAM.
2. Uses **page number** to index into the page table â†’ gets physical frame number.
3. Combines frame number + offset â†’ final physical address.

If the page table entry is **invalid**, a **page fault** occurs.

---

# Examples of Virtual Memory and Paging

### Example 1: Initial State
*   **Process A starts.**
*   **Page table** created at physical addr `0x100000`.
*   **PTBR** (Page Table Base Register) â† `0x100000`.
*   All 1024 entries = **invalid**.
   
### Example 2: First Access
*   Code reads from virtual `0x1000` (page 1, offset 0).
*   **Page fault** â†’ OS maps page 1 â†’ physical frame `0x5000`.
*   **Page table[1]** = `0x5` (frame number), valid=1.

### Example 3: Data Access
*   Program writes to `0x3ABC` (page 3, offset 0xBC).
*   If unmapped â†’ **page fault** â†’ OS allocates frame `0x8000`.
*   **Physical address** = `0x8000 + 0xBC = 0x80BC`.
    
### Example 4: Internal Fragmentation
*   Heap allocates 2049 bytes â†’ spans 2 pages (0â€“4095).
*   Only 2049 bytes used â†’ **2047 bytes wasted** (internal fragmentation).
    
### Example 5: Context Switch   
*   Switch to **Process B**.
*   OS loads Bâ€™s page table base into **PTBR**.
*   Now all virtual addresses use Bâ€™s mappings.


## Workflow Diagram (Single-Level Paging)

```mermaid
flowchart TD
    A[Process Starts] --> B["OS creates empty page table (all entries = invalid)"]
    B --> C[Load page table base into PTBR]
    C --> D{Program accesses virtual address?}
    D -->|Yes| E["MMU splits addr: page# + offset"]
    E --> F{Page table entry valid?}
    F -->|No| G[Page Fault!]
    G --> H[OS allocates free physical frame]
    H --> I["Load data if needed (e.g., from disk)"]
    I --> J["Update page table entry (mark as valid)"]
    J --> K[Restart instruction]
    F -->|Yes| L["MMU computes physical address: (frame << 12) + offset"]
    L --> M[Access physical memory]
    K --> D
    M --> D




