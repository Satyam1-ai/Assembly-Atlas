# Early Paging Fundamentals: Single-Level Virtual Memory

This document explains the core concepts of **single-level paging** as used in early virtual memory systems (e.g., Atlas, IBM System/360 Model 67). Unlike modern multi-level schemes, early paging used a flat page table per process‚Äîsimple, efficient, and foundational to all modern memory management.

> üí° **Key Idea**: Virtual memory gives each process the illusion of a large, contiguous address space‚Äîeven though its data may be scattered across physical RAM.

---

## Core Components

| Component | Role |
|---------|------|
| **Virtual Address** | Generated by the program (e.g., `0x12345`). Split into **page number** + **offset**. |
| **Page Table** | An array where each entry maps a virtual page ‚Üí physical frame. Created per process. |
| **PTBR** (Page Table Base Register) | Hardware register holding the **physical address** of the current process‚Äôs page table. |
| **MMU** (Memory Management Unit) | Hardware that translates virtual ‚Üí physical addresses using PTBR + page table. |
| **Page Fault** | CPU exception triggered when accessing an unmapped (invalid) virtual page. |

> üìå **Note**: The **offset is part of the virtual address itself**‚Äîit is **not stored in PTBR**.

---

## Address Translation (32-bit, 4KB Pages)

- Page size = 4KB ‚Üí **12-bit offset**
- Virtual address = 32 bits ‚Üí **20-bit page number** + **12-bit offset**
Virtual Address: [ 20-bit Page Number | 12-bit Offset ] ‚îî‚îÄ‚îÄ‚îÄ index into ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ byte in page ‚îÄ‚îò


**Translation Steps**:
1. MMU reads **PTBR** to locate the page table in physical RAM.
2. Uses **page number** to index into the page table ‚Üí gets physical frame number.
3. Combines frame number + offset ‚Üí final physical address.

If the page table entry is **invalid**, a **page fault** occurs.

---

## Workflow Diagram (Single-Level Paging)

```mermaid
flowchart TD
    A[Process Starts] --> B[OS creates empty page table\n(all entries = invalid)]
    B --> C[Load page table base into PTBR]
    C --> D{Program accesses\nvirtual address?}
    D -->|Yes| E[MMU splits addr:\npage# + offset]
    E --> F{Page table entry\nvalid?}
    F -->|No| G[Page Fault!]
    G --> H[OS allocates free physical frame]
    H --> I[Load data if needed\n(e.g., from disk)]
    I --> J[Update page table entry\n(mark as valid)]
    J --> K[Restart instruction]
    F -->|Yes| L[MMU computes physical address:\n(frame << 12) + offset]
    L --> M[Access physical memory]
    K --> D
    M --> D


# Examples of Virtual Memory and Paging

### Example 1: Initial State
*   **Process A starts.**
*   **Page table** created at physical addr `0x100000`.
*   **PTBR** (Page Table Base Register) ‚Üê `0x100000`.
*   All 1024 entries = **invalid**.

### Example 2: First Access
*   Code reads from virtual `0x1000` (page 1, offset 0).
*   **Page fault** ‚Üí OS maps page 1 ‚Üí physical frame `0x5000`.
*   **Page table[1]** = `0x5` (frame number), valid=1.

### Example 3: Data Access
*   Program writes to `0x3ABC` (page 3, offset 0xBC).
*   If unmapped ‚Üí **page fault** ‚Üí OS allocates frame `0x8000`.
*   **Physical address** = `0x8000 + 0xBC = 0x80BC`.

### Example 4: Internal Fragmentation
*   Heap allocates 2049 bytes ‚Üí spans 2 pages (0‚Äì4095).
*   Only 2049 bytes used ‚Üí **2047 bytes wasted** (internal fragmentation).

### Example 5: Context Switch
*   Switch to **Process B**.
*   OS loads B‚Äôs page table base into **PTBR**.
*   Now all virtual addresses use B‚Äôs mappings.
 
